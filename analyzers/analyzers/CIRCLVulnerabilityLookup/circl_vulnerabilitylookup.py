#!/usr/bin/env python3
# encoding: utf-8

from cortexutils.analyzer import Analyzer
from pyvulnerabilitylookup import PyVulnerabilityLookup
import re

class CIRCLVulnerabilityLookup(Analyzer):
    def __init__(self):
        Analyzer.__init__(self)
        self.url = self.get_param(
            "config.url", "https://vulnerability.circl.lu/", "token parameter is missing"
        )
        self.token = self.get_param(
            "config.token", None, "url parameter is missing"
        )

    def parse_epss_short_report(self, epss_raw):
        try:
            data = epss_raw.get("data", [])[0]
            epss_score = float(data.get("epss", 0))
            percentile = float(data.get("percentile", 0))
        except (IndexError, ValueError, TypeError):
            return None, None, None

        if percentile >= 0.90:
            level = "malicious"
            label = "Very High"
        elif percentile >= 0.70:
            level = "suspicious"
            label = "High"
        elif percentile >= 0.40:
            level = "suspicious"
            label = "Moderate"
        elif percentile >= 0.10:
            level = "info"
            label = "Low"
        else:
            level = "safe"
            label = "Very Low"

        short_report = f"EPSS Risk: {label} (Score {epss_score:.2f}, {round(percentile * 100)}th percentile)"

        taxonomy = self.build_taxonomy(
            level,
            "CIRCLVulnL",
            f"epss",
            f"{label} ({round(percentile * 100)}th percentile)"
        )

        return short_report, taxonomy, label.lower().replace(" ", "-")

    def extract_cvss_scores(self, vuln_data):
        scores = {}
        metrics_legacy = vuln_data.get("metrics", {})
        metrics_cna = vuln_data.get("containers", {}).get("cna", {}).get("metrics", [])

        version_mapping = {
            "cvssMetricV2": "2.0",
            "cvssMetricV30": "3.0",
            "cvssMetricV31": "3.1",
            "cvssMetricV40": "4.0"
        }

        # Legacy CVSS structure
        for key, version in version_mapping.items():
            metric_data = metrics_legacy.get(key, [])
            if metric_data:
                cvss_data = metric_data[0].get("cvssData", {})
                scores[version] = {
                    "score": cvss_data.get("baseScore"),
                    "vector": cvss_data.get("vectorString"),
                    "severity": cvss_data.get("baseSeverity"),
                    "exploitabilityScore": metric_data[0].get("exploitabilityScore"),
                    "impactScore": metric_data[0].get("impactScore")
                }

        # CVE 5.1 format (containers.cna.metrics)
        for entry in metrics_cna:
            for key in entry:
                if key.startswith("cvssV"):
                    version = key.replace("cvssV", "")
                    version = version.replace("_", ".")
                    data = entry[key]
                    scores[version] = {
                        "score": data.get("baseScore"),
                        "vector": data.get("vectorString"),
                        "severity": data.get("baseSeverity"),
                        "exploitabilityScore": entry.get("exploitabilityScore"),
                        "impactScore": entry.get("impactScore")
                    }

        return scores

    def run(self):
        observable = self.get_data()
        datatype = self.data_type

        if not ("vuln" in datatype.lower() or "cve" in datatype.lower() or datatype.lower() == "other"):
            self.error(f"Unsupported data type: {datatype}")

        try:
            vuln_lookup = PyVulnerabilityLookup(self.url, token=self.token)

            vulnerability = vuln_lookup.get_vulnerability(vulnerability_id=observable) or {}
            sightings = vuln_lookup.get_sightings(vuln_id=observable) or {}
            epss = vuln_lookup.get_epss(vulnerability=observable) or {}
            comments = vuln_lookup.get_comments(vuln_id=observable) or {}

            if not any([sightings, epss]):
                self.error(f"No data found for {observable}. CVE might be unknown or not indexed.")

            sighting_stats = {}
            total_sightings = 0

            for s in sightings.get("data", []):
                t = s.get("type", "unknown")
                sighting_stats[t] = sighting_stats.get(t, 0) + 1
                total_sightings += 1

            cvss_scores = self.extract_cvss_scores(vulnerability)

        except Exception as e:
            self.error(f"Error querying vulnerability data: {str(e)}")

        short_report_lines = []
        epss_report, _, epss_tag = self.parse_epss_short_report(epss)
        if epss_report:
            short_report_lines.append(epss_report)

        for version, score_data in cvss_scores.items():
            severity = score_data.get("severity")
            score = score_data.get("score")
            line = f"CVSS {version}: {severity if severity else 'Unknown'} ({score if score is not None else 'N/A'})"
            if score_data.get("exploitabilityScore") is not None:
                line += f", Exploitability: {score_data.get('exploitabilityScore')}"
            if score_data.get("impactScore") is not None:
                line += f", Impact: {score_data.get('impactScore')}"
            short_report_lines.append(line)

        self.report({
            "vulnerability": vulnerability,
            "cvss_scores": cvss_scores,
            "comments": comments,
            "sightings": sightings,
            "epss": epss,
            "url": f"https://vulnerability.circl.lu/vuln/{observable}",
            "short_report": short_report_lines,
            "stats": {
                "sightings_by_type": sighting_stats,
                "total_sightings": total_sightings
            },
            "_epss_tag": epss_tag
        })

    def summary(self, raw):
        taxonomies = []
        namespace = "CIRCLVulnL"
        predicate = self.data_type

        cvss_scores = raw.get("cvss_scores", {})
        max_score = 0
        selected = None

        for version, entry in cvss_scores.items():
            score = entry.get("score")
            if score is not None and score > max_score:
                max_score = score
                selected = entry

        if selected:
            if max_score >= 9.0:
                level_cvss = "malicious"
                value_cvss = f"Critical (CVSS {max_score})"
            elif max_score >= 7.0:
                level_cvss = "malicious"
                value_cvss = f"High (CVSS {max_score})"
            elif max_score >= 4.0:
                level_cvss = "suspicious"
                value_cvss = f"Medium (CVSS {max_score})"
            else:
                level_cvss = "info"
                value_cvss = f"Low (CVSS {max_score})"
        else:
            level_cvss = "safe"
            value_cvss = "No CVSS score"

        taxonomies.append(
            self.build_taxonomy(level_cvss, namespace, f"cvss", value_cvss)
        )

        sightings_data = raw.get("sightings", {}).get("data", [])
        type_counts = {}
        for s in sightings_data:
            t = s.get("type", "unknown")
            type_counts[t] = type_counts.get(t, 0) + 1

        if type_counts.get("exploited"):
            level_sightings = "malicious"
            value_sightings = f"Exploited ({type_counts['exploited']} times)"
        elif type_counts.get("seen"):
            level_sightings = "suspicious"
            value_sightings = f"Seen ({type_counts['seen']} times)"
        elif sightings_data:
            level_sightings = "suspicious"
            value_sightings = f"Other sightings ({len(sightings_data)} total)"
        else:
            level_sightings = "info"
            value_sightings = "No sightings"

        taxonomies.append(
            self.build_taxonomy(level_sightings, namespace, f"sightings", value_sightings)
        )

        epss_report, epss_taxonomy, _ = self.parse_epss_short_report(raw.get("epss", {}))
        if epss_taxonomy:
            taxonomies.append(epss_taxonomy)

        return {"taxonomies": taxonomies}

    def operations(self, raw):
        operations = []
        tag = raw.get("_epss_tag")
        if tag:
            operations.append(self.build_operation("AddTagToArtifact", tag=f"epss:{tag}"))
        return operations

    def artifacts(self, raw):
        return []

if __name__ == "__main__":
    CIRCLVulnerabilityLookup().run()
